# 1. Is+As+强转三者性能测试

条件：测试is、as、强制转换，执行**100万**次。

结论：

1. 三者性能相近；测试有波动，互有胜负。

| 类型 | 耗时      |
| ---- | --------- |
| is   | 0.0024721 |
| as   | 0.0029023 |
| 强转 | 0.002057  |



# 2. LINQ查询和普通查找效率对比

条件：设查找过程为构造、判断、第一个元素，即LINQ调用Select、Where、FirstOrDefault函数，执行**100万**次。

结论：

1. 两者的查询效率相差不大，LINQ相对较慢一些；

| 类型     | 耗时                                     |
| -------- | ---------------------------------------- |
| 普通查找 | <font color="green">**1.9634961**</font> |
| LINQ     | 2.5473344                                |



# 3. 类层次数量性能测试

条件：设有类Base、DerivedLevel1、DerivedLevel2、DerivedLevel3，依次继承前者，都有完全相同的函数（覆盖），执行该函数**100万**次。

结论：

1. 继承层次对性能影响不大，运行时间基本一致，误差考虑为波动；

| 类型                           | 耗时      |
| ------------------------------ | --------- |
| 继承一层：DerivedLevel1.Func() | 0.0664967 |
| 继承两层：DerivedLevel2.Func() | 0.0726356 |
| 继承三层：DerivedLevel3.Func() | 0.0693595 |



# 4. 结构体和类的属性赋值效率对比

条件：设相同结构的结构体和类，分别有4个属性，且嵌套一层。调用全部属性赋值**1000万**次，相当于深拷贝1000万次。

结论：

1. 结构体的赋值性能远高于类的属性赋值，且在对象拷贝的情况下会十分方便；

| 类型   | 耗时                                     |
| ------ | ---------------------------------------- |
| 结构体 | <font color="green">**0.0294046**</font> |
| 类     | 0.7444613                                |



# 6. List移除元素

条件：设 list 有10万个字符串元素，调用移除**10万**次。

结论：

1. List<T>删除末尾元素的性能更高；
2. 扩展函数性能稍差于直接调用；
3. 尝试内联效果不够理想；

| 方式                                                    | 耗时                                        |
| ------------------------------------------------------- | :------------------------------------------ |
| 1. 直接删除                                             | <font color="red">**02.3013583**</font> s   |
| 2. 移动末尾到删除位置，删除末尾                         | 00.00<font color="green">**19092**</font> s |
| 3. 使用扩展函数：移动末尾到删除位置，删除末尾           | 00.00<font color="green">**39788**</font> s |
| 4. 使用尝试内联的扩展函数：移动末尾到删除位置，删除末尾 | 00.00<font color="green">**37990**</font> s |



# 7. List 和 Dictionary 查询效率对比

条件：设 list 和 dic 分别有2、10、100、1000、10000个元素，调用查找居中位置的元素**1万**次。

结论：

1. 不论在那个数量级，dic 的性能始终高于 list，且 dic 的耗时基本与数量级无关；

| 数量级 | list       | dic                                       |
| ------ | ---------- | :---------------------------------------- |
| 2      | 00.0054734 | 00.00<font color="green">**27516**</font> |
| 10     | 00.0154656 | 00.00<font color="green">**23576**</font> |
| 100    | 00.1174241 | 00.00<font color="green">**22552**</font> |
| 1000   | 01.7854391 | 00.00<font color="green">**29942**</font> |
| 10000  | 12.5844444 | 00.00<font color="green">**22011**</font> |



# 8. 反射设置属性和直接设置属性效率对比

条件：调用设置对象属性**1万**次。

结论：

1. 反射设置属性耗时大约是直接设置属性的两倍；
2. GetType+GetProperty的消耗并不大，SetValue占主要部分；

| 数量级                                          | list       |
| ----------------------------------------------- | ---------- |
| 直接设置                                        | 00.0280895 |
| 反射（GetType+GetProperty+SetValue）* 1万次     | 00.0511058 |
| 反射（GetType+GetProperty）+（SetValue）* 1万次 | 00.0538688 |

